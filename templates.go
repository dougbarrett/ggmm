package main

var mainGo = `package main

import (
	"log"
	"fmt"
	"io/ioutil"
	"net/http"
	"encoding/json"
	
	"{{ .CurrentRepo}}/controllers"
	"{{ .CurrentRepo }}/models"

	"github.com/go-martini/martini"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jinzhu/gorm"
	"github.com/martini-contrib/render"
	"github.com/martini-contrib/sessions"
)

var (
	db gorm.DB
)

type GgmmConfig struct {
	ApplicationName string
	Database        struct {
		Username string
		Password string
		Server   string
		Port     string
		Database string
	}
	AllowRegistration bool
	SessionKey 		  string
}

var retDataDefaults models.RetDataDefaults

func loadConfig() (config *GgmmConfig) {
	b, err := ioutil.ReadFile("config.json")

	if err != nil {
		log.Fatalf("Cannot load config: %s", err)
	}

	err = json.Unmarshal(b, &config)

	if err != nil {
		log.Fatalf("config.json not in correct format: %s", err)
	}
	return
}

func main() {
	var err error

	config := loadConfig()
	retDataDefaults.AppName = config.ApplicationName
	retDataDefaults.AllowRegistration = config.AllowRegistration


	log.Printf("Booting up %s", config.ApplicationName)

	dbConn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true",
		config.Database.Username,
		config.Database.Password,
		config.Database.Server,
		config.Database.Port,
		config.Database.Database)

	db, err = gorm.Open("mysql", dbConn)
	db.LogMode(true)

	if err != nil {
		log.Fatalf("Database connection issue: %s", err)
	}

	models.Bootstrap(&db)

	m := martini.Classic()

	store := sessions.NewCookieStore([]byte(config.SessionKey))
	m.Use(sessions.Sessions(fmt.Sprintf("%sApp", config.ApplicationName), store))

	m.Map(&retDataDefaults)

	m.Use(render.Renderer(render.Options{
		Layout: "layout",
	}))

	m.Use(func(res http.ResponseWriter, req *http.Request, session sessions.Session, c martini.Context, rdd *models.RetDataDefaults) {
		{{ if eq .AllowRegistration true }}
		v := session.Get("user_id")
		if v != nil {
			var user models.LoggedIn
			db.Find(&user, v.(uint))
			c.Map(&user)
		} else {
			var user models.LoggedIn
			c.Map(&user)
		}
		{{ else }}
		var user models.LoggedIn
		c.Map(&user)	
		{{ end }}
	})

	controllers.UserBootstrap(m)
	controllers.Bootstrap(m)

	m.Run()
}`

var controllerExtraGo = `package controllers

import (
	"github.com/go-martini/martini"
)

func UserBootstrap(m *martini.ClassicMartini) {

}
`

var controllerUserGo = `package controllers

// This file is generated specifically for
// you to be able to add logic to

// This logic is read before generate logic


import (
	"github.com/go-martini/martini"
)

func UserBootstrap(m *martini.ClassicMartini) {
	// Add your martini controller logic here
	m.Get("/hello-world", helloWorld)
}

// Here is the example function

func helloWorld() string {
	return "Hello, world!"
}
`

var controllersBootstrapGo = `package controllers

// This file is automatically generated,
// do not edit or chances are it will be
// overwritten.

import (
	"log"

	"github.com/go-martini/martini"

	{{ if ne .LoginCrud "" }}
	"net/http"
	"{{ .CurrentRepo }}/models"
	"github.com/martini-contrib/binding"
	"github.com/martini-contrib/render"
	"github.com/martini-contrib/sessions"
	{{ end }}
)

func Bootstrap(m *martini.ClassicMartini) {
	log.Println("Bootstraping controllers")
	{{ range .GetControllers }}
	m.Get("{{ .Route }}", {{ .Function }})
	{{ end }}

	log.Println("Bootstraping CRUD")
	{{ range .CrudControllers }}
	m.Get("/{{ .Routed }}s/all", controller{{ .Name }}sAll)
	m.Get("/{{ .Routed }}s/new", controller{{ .Name }}New)
	m.Get("/{{ .Routed }}s/view/:id", binding.Bind(models.{{ .Name }}{}), controller{{ .Name }}View)
	m.Post("/{{ .Routed }}s/save", controller{{ .Name }}Save)
	m.Post("/{{ .Routed }}s/delete", binding.Bind(models.{{ .Name }}{}), controller{{ .Name }}Delete)
	{{ end }}

	{{ if ne .LoginCrud "" }}

	m.Get("/register", controllerRegister)
	m.Post("/register", binding.Bind(models.User{}), controllerRegisterPost)
	m.Get("/login", controllerLogin)
	m.Post("/login", binding.Bind(models.User{}), controllerLoginPost)
	m.Get("/logout", controllerLogout)

	{{ end }}
}

func UsersView() string {
	return "Users View"
}

{{ if ne .LoginCrud "" }}

func controllerRegister(rdd *models.RetDataDefaults, r render.Render) {
	var retData struct {
		*models.RetDataDefaults
	}
	retData.RetDataDefaults = rdd
	r.HTML(http.StatusOK, "register", retData)
}

func controllerRegisterPost(user models.{{ .LoginCrud }}, rdd *models.RetDataDefaults, session sessions.Session, r render.Render, req *http.Request) {
	err := user.Register()

	if err != nil {
		r.JSON(http.StatusInternalServerError, "User cannot be registered")
		return
	}

	session.Set("user_id", user.ID)
	r.JSON(http.StatusOK, "OK")
}

func controllerLogin(rdd *models.RetDataDefaults, r render.Render) {
	var retData struct {
		*models.RetDataDefaults
	}
	retData.RetDataDefaults = rdd
	r.HTML(http.StatusOK, "login", retData)
}

func controllerLogout(session sessions.Session, r render.Render, req *http.Request) {
	ops := sessions.Options{
		MaxAge: -1,
	}
	session.Options(ops)
	session.Clear()
	r.Redirect(req.Referer())
}

func controllerLoginPost(user models.{{ .LoginCrud }}, rdd *models.RetDataDefaults, session sessions.Session, r render.Render, req *http.Request) {
	user, err := user.CanLogin()

	if err != nil {
		r.JSON(http.StatusInternalServerError, "User cannot login")
		return
	}

	session.Set("user_id", user.ID)
	r.JSON(http.StatusOK, "OK")
}
{{ end }}
`

var controllersHomeGo = `
package controllers

import (
	"net/http"

	"{{ .CurrentRepo }}/models"
	"github.com/martini-contrib/render"
)

func controllerHome(user *models.LoggedIn, rdd *models.RetDataDefaults, r render.Render) {
	var retData struct {
		*models.RetDataDefaults
	}
	retData.RetDataDefaults = rdd
	retData.LoggedIn = user
	retData.CurrentPage = "home"

	r.HTML(http.StatusOK, "home", retData)
}

`

var modelsBootstrapGo = `package models

// This file is automatically generated,
// do not edit or chances are it will be
// overwritten.

import (
	"log"

	"github.com/jinzhu/gorm"
)

var db *gorm.DB

type RetDataDefaults struct {
	AppName            string
	CurrentPage        string
	AllowRegistration  bool
	OutputErrorMessage string
	LoggedIn           *LoggedIn
	SiteModals         []string
}

type LoggedIn struct {
	{{ if ne .LoginCrud "" }}
	{{ .LoginCrud }}GeneratedFields
	{{ else }}
	ID uint
	{{ end }}
}

{{ if ne .LoginCrud "" }}
func (li LoggedIn) TableName() string {
	return "{{ .LoginCrudLower }}s"
}
{{ end }}

{{ range .CrudControllers }}
type {{ .Name }}GeneratedFields struct {
	{{ range .Model }}
	{{ .Name }} {{ .Type }}` + "`{{ .Config }}`" + `
	{{ end }}
}
{{ if eq .Template "user" }}
	import (

	"errors"
	"golang.org/x/crypto/bcrypt"
	"time"
	)

	func (user *{{ .Name }}) CanLogin() (tempUser {{ .Name }}, err error) {
		err = db.Where("email = ?", user.Email).Find(&tempUser).Error
		if err != nil {
			return
		}

		password := []byte(user.Password)
		hashedPassword := []byte(tempUser.Password)

		err = bcrypt.CompareHashAndPassword(hashedPassword, password)

		if err != nil {
			return
		}

		return
	}

	func (user *{{ .Name }}) Register() (err error) {
		var tempUser {{ .Name }}
		err = db.Where("email = ?", user.Email).Find(&tempUser).Error

		if err == nil {
			err = errors.New("User was found")
			return
		}

		if user.Password != user.PasswordRepeat {
			err = errors.New("Passwords do not match")
			return
		}

		password := []byte(user.Password)
		hashedPassword, err := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)

		if err != nil {
			return
		}

		user.Password = string(hashedPassword)
		db.Save(&user)
		return
	}
{{ end }}
{{ end }}

func Bootstrap(adb *gorm.DB) {
	db = adb
	log.Println("Checking tables to be generated")
	db.AutoMigrate({{ range $i, $v := .CrudControllers}}{{ if $i }},{{end}}&{{.Name}}{}{{ end }})
}`

var modelsCrudGo = `package models

type {{ .Name }} struct {
	{{ .Name }}GeneratedFields
}
`

var controllersCrudGo = `package controllers

import (
	"fmt"

	"{{ .Config.CurrentRepo }}/models"

	"github.com/go-martini/martini"
)

func controller{{ .Crud.Name }}sAll() string {
	return "{{ .Crud.Name }}s list all"
}

func controller{{ .Crud.Name }}New() string {
	return "New {{ .Crud.Name }}"
}

func controller{{ .Crud.Name }}View(p martini.Params) string {
	return fmt.Sprintf("%s view", p["id"])
}

func controller{{ .Crud.Name }}Save({{ .Crud.Name }} models.{{ .Crud.Name }}) string {
	return fmt.Sprintf("Save {{ .Crud.Name }}")
}

func controller{{ .Crud.Name }}Delete({{ .Crud.Name}} models.{{ .Crud.Name }}) string {
	return fmt.Sprintf("Delete {{ .Crud.Name }}")
}
`

var templateCrudForm = `<form action="/{{ .Routed }}/save" method="post">
	<h3>{{ .State }} {{ .Crud.Name }}</h3>

	{{ range .Crud.Model }}
	{{ if eq .Form.Hidden true }}
	<input type="hidden" name="{{ .Name }} value="[[ .{{ .Name }} ]]"/>
	{{ end }}
	{{ end }}
	<div class="container">
		{{ range .Crud.Model }}
		{{ if eq .Form.Hidden false }}
		[[ $rm := . ]]
		<div class="row">
			<div class="col-sm-12">
				<div class="form-group">
					<label for="{{ .Name }}">{{ .Name }}</label>
					{{ if eq .Form.Type "text" }}
					<input type="text" name="{{ .Name }}" id="form_{{ .Name }}" value="[[ .{{ .Name }} ]]" class="form-control"/>
					{{ end }}
					{{ if eq .Form.Type "email" }}
					<input type="email" name="{{ .Name }}" id="form_{{ .Name }}" value="[[ .{{ .Name }} ]]" class="form-control"/>
					{{ end }}
					{{ if eq .Form.Type "password" }}
					<input type="password" name="{{ .Name }}" id="form_{{ .Name }}" value="[[ .{{ .Name }} ]]" class="form-control"/>
					{{ end }}
					{{ if eq .Form.Type "select" }}
					<select name="{{ .Name }}" id="form_{{ .Name }}" class="form-control">
						{{ range .Form.SelectOptions }}
						<option value="{{ . }}" [[ if eq $rm.{{ .Name }} . ]]selected="SELECTED"[[ end ]]>{{ .Name }}</option>
						{{ end }}
					</select>
					{{ end }}
				</div>
			</div>
		</div>
		{{ end }}
		{{ end }}
	</div>
	<div class="container">
		<div class="row">
			<div class="col-sm-12">
				<input type="submit" value="Save" class="btn btn-primary" />
			</div>
		</div>
	</div>
</form>`
